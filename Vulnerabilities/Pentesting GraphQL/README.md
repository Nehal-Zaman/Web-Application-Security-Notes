# GraphQL API Vulnerabilities

# What is GraphQL?

GraphQL is a type of API query language that enables a client to specify exactly what they want in response, hence large response objects are avoided as it is seen in REST API sometimes.

# How GraphQL works?

GraphQL `schema` defines the structure of the data, listing the available objects, fields and relationships.

Data in graphQL schema can be manipulated by 3 types of operations:

- `Queries`: fetch data.
- `Mutations`: add/change/remove data.
- `Subscriptions`: also fetches data; but it sets up a permanent connection through which a server can push data to a client in a specified format.

All graphQL operations use the same endpoint, using mostly `POST` request.

The type and name of the operation defines how the graphQL query will be handled.

# An example schema

```graphql
#Example schema definition

type Product {
	id: ID!
	name: String!
	description: String!
	price: Int
}
```

An example schema showing a simple definition for a `product` type. The `!` operator indicates that the `field` can not be `null`.

Each `field` has its own type: it can be another object or a scalar.

Schema must include at least one available query. Generally it also contains details of available mutations.

# GraphQL query

`Queries` are used to fetch data from datastore. They are similar to `GET` request in `REST` API.

They have 3 components:

- The `query` operation type.
- A query name: can be anything you want.
- A data structure: data that the query should return.
- Optional 1 or more arguments to get specific data.

```graphql
#Example query
query myGetProductQuery {
	getProduct(id: 123) {
	  name
	  description
	}
}
```

# GraphQL mutation

`Mutations` are used to manipulate data in a way. They are similar to `REST`'s `POST`, `PUT` and `DELETE`.

Like queries, they also have a operation type, name and structure for the returned data.

```graphql
#Example mutation request
mutation {
	createProduct(name: "Flamin' Cocktail Glasses", listed: "yes") {
		id
		name
		listed
	}
}
```

An example response will be something like below:

```graphql
#Example mutation response
{
	"data": {
	  "createProduct": {
	    "id": 123,
      "name": "Flamin' Cocktail Glasses",
      "listed": "yes"
    }
  }
}
```

# Fields

Fields are the queryable data contained in the graphQL types.

In the examples above, `id`, `name`, `description`, `listed` etc. are all fields.

# Arguments

Arguments are values that are provided for specific fields. 

The arguments that are accepted for a type are defined in the schema.

In the `query` example, `123` as `id` value is the argument.

# Variables

Variables enable you to pass arguments dynamically rather than having arguments hardcoded in the query itself.

When building a query/mutation that uses variables, you need to:

- Declare the variable and type.
- Add the variable name in the appropriate place in the query.
- Pass the variable key and value from the variable dictionary.

```graphql
#Example query with variable
query getEmployeeWithVariable($id: ID!) {
	getEmployees(id:$id) {
	  name {
	    firstname
		  lastname
	  }
	}
}

Variables:
	{
		"id": 1
	}
```

# Aliases

GraphQL objects can not contain multiple properties with the same name.

Aliases are used to bypass this restriction by explicitly naming the properties you want the API to return.

```graphql
#Invalid query
query getProductDetails {
	getProduct(id: 1) {
	  id
    name
  }
	getProduct(id: 2) {
		id
	  name
  }
}
```

```graphql
#Valid query using aliases
query getProductDetails {
	product1: getProduct(id: "1") {
	  id
	  name
	}
	product2: getProduct(id: "2") {
    id
    name
  }
}
```

Valid response:

```graphql
#Response to query

    {
        "data": {
            "product1": {
                "id": 1,
                "name": "Juice Extractor"
             },
            "product2": {
                "id": 2,
                "name": "Fruit Overlays"
            }
        }
    }
```

# Fragments

Fragments are reusable parts of queries or mutations.

They contain a subset of the fields belonging to the associated type.

```graphql
#Example fragment

    fragment productInfo on Product {
        id
        name
        listed
    }
```

```graphql
#Query calling the fragment

    query {
        getProduct(id: 1) {
            ...productInfo
            stock
        }
    }
```

```graphql
#Response including fragment fields

    {
        "data": {
            "getProduct": {
                "id": 1,
                "name": "Juice Extractor",
                "listed": "no",
                "stock": 5
            }
        }
    }
```

# Subscriptions

It is a special type of query that enables a client to establish a long-lived connection with a server, so that the server can push real-time updates to the client without the need to continually poll for data.

They are used for small changes to large objects and for functionality that requires small real time updates (like chat systems or collaborative editing).

They are commonly implemented using `websockets`.

# Introspection

`Introspection` is a built-in graphQL function that enables you to query a server for information about the schema.

They are mostly used by documentation generation tools.

It is best practice to disable `introspection` in production environments, due to the risk it has.

NOW, letâ€™s talk SECURITY.

# Finding GraphQL endpoints

GraphQL uses a single endpoint for all it queries. Before we start testing it, we need to figure that out:

## Universal queries

If we send `query{__typename}` to any graphQL endpoint, the response will include `{"data":{"__typename":"query"}}` somewhere. This is called universal query and it can be used to find graphQL endpoint.

## Common endpoint names

Try sending universal queries to the following common endpoint names:

```
/graphql
/api
/api/graphql
/graphql/api
/graphql/graphql
```

If this does not work, you can also try appending `/v1` to the path and repeat again.

GraphQL services will often respond to any non-graphQL request with a `query not present` or something like that.

## Request methods

If you can not find graphQL endpoints using `POST` request to common endpoints, try sending the universal query using alternate HTTP methods like `GET`.

## Initial testing

If you have found the graphQL endpoint, try spending some time playing it to figure out how it is working. If the graphQL is powering an web application, try intercepting the web application requests, look at `burp HTTP history` to examine the queries that are sent.

# Exploiting unsanitised arguments

If graphQL is using `arguments` to access objects directly, it might be vulnerable to `Broken Access Control`. 

A user could potentially access information that they should not have access to, by supplying an argument that corresponds to that information (`IDOR`).

# Discovering schema information

Once you find the graphQL endpoint, the next step would be to gather information about the underlying `schema`.

## Using introspection

To use introspection for finding `schema` information, you need to query the `__schema` field. This field is available on the root type of all queries.

```graphql
#Introspection probe request
{
	"query": "{__schema{queryType{name}}}"
}
```

## Running a full introspection query

```graphql
#Full introspection query

    query IntrospectionQuery {
        __schema {
            queryType {
                name
            }
            mutationType {
                name
            }
            subscriptionType {
                name
            }
            types {
             ...FullType
            }
            directives {
                name
                description
                args {
                    ...InputValue
            }
            onOperation  #Often needs to be deleted to run query
            onFragment   #Often needs to be deleted to run query
            onField      #Often needs to be deleted to run query
            }
        }
    }

    fragment FullType on __Type {
        kind
        name
        description
        fields(includeDeprecated: true) {
            name
            description
            args {
                ...InputValue
            }
            type {
                ...TypeRef
            }
            isDeprecated
            deprecationReason
        }
        inputFields {
            ...InputValue
        }
        interfaces {
            ...TypeRef
        }
        enumValues(includeDeprecated: true) {
            name
            description
            isDeprecated
            deprecationReason
        }
        possibleTypes {
            ...TypeRef
        }
    }

    fragment InputValue on __InputValue {
        name
        description
        type {
            ...TypeRef
        }
        defaultValue
    }

    fragment TypeRef on __Type {
        kind
        name
        ofType {
            kind
            name
            ofType {
                kind
                name
                ofType {
                    kind
                    name
                }
            }
        }
    }
```

One liner:

```graphql
{__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description locations args{...InputValue}}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}inputFields{...InputValue}interfaces{...TypeRef}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name}}}}}}}}
```

Alternate one liner:

```graphql
__schema{queryType{name},mutationType{name},types{kind,name,description,fields(includeDeprecated:true){name,description,args{name,description,type{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}},defaultValue},type{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}},isDeprecated,deprecationReason},inputFields{name,description,type{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}},defaultValue},interfaces{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}},enumValues(includeDeprecated:true){name,description,isDeprecated,deprecationReason,},possibleTypes{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}}},directives{name,description,locations,args{name,description,type{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name,ofType{kind,name}}}}}}}},defaultValue}}}
```

## Visualizing introspection results

Introspection query responses may sometimes be hard to process. For this we can use [graphql-visualizer](http://nathanrandal.com/graphql-visualizer/).

As an alternative, burpâ€™s plugin [InQL](https://portswigger.net/burp/documentation/desktop/testing-workflow/session-management/working-with-graphql) can be used.

## Suggestions

Even if the introspection is disabled, you can sometimes use `suggestions` to glean information on an APIâ€™s structure.

Suggestions are generally used where queries are slightly incorrect but still recognizable.

It is used by `Apollo` GraphQL platform.

[Clairvoyance](https://github.com/nikitastupin/clairvoyance) is a tool that uses suggestions to automatically recover all or part of GraphQL schema.

# Bypassing GraphQL introspection filters

- If some kind of regex is used to filter keyword like `__schema{` you can use characters like comma (`,`), spaces and newlines as they are ignored by GraphQL but not by flawed regex.

```graphql
#Introspection query with newline

    {
        "query": "query{__schema
        {queryType{name}}}"
    }
```

- Try changing `POST` to `GET` request, or change content-type to `x-www-form-urlencoded`.

```graphql
# Introspection probe as GET request

    GET /graphql?query=query%7B__schema%0A%7BqueryType%7Bname%7D%7D%7D
```

# Bypassing rate limits using aliases

Many endpoints may have a rate limiter in place to prevent brute force attacks. 

If the rate limit is not working based on the number of operations performed on the graphQL endpoint (for e.g. it might be working based on the number of HTTP requests on an endpoint), `aliases` may be used to bypass the rate limit.

Since `aliases` allow us to send multiple queries in a single HTTP request, you can leverage this to bypass the restriction.

```graphql
#Request with aliased queries

    query isValidDiscount($code: Int) {
        isvalidDiscount(code:$code){
            valid
        }
        isValidDiscount2:isValidDiscount(code:$code){
            valid
        }
        isValidDiscount3:isValidDiscount(code:$code){
            valid
        }
    }
```

In the above example, you can see that 3 queries are being made in a single HTTP request.

# CSRF over GraphQL

*Cross Site Request Forgery* (`CSRF`) is a kind of web security vulnerability where a malicious user can induce a victim to perform an unintended action by creating a malicious website that forges a cross-domain request to the vulnerable application.

You can learn more about CSRF in my [notes](https://github.com/Nehal-Zaman/Web-Application-Security-Notes/blob/main/Vulnerabilities/CSRF/CSRF.md).

GraphQL can be used as a vector for CSRF attacks to make a victimâ€™s browser send a malicious query as the victim user.

Conditions for exploiting CSRF over graphQL:

- the endpoint does not validate the `content-type` of the request.
- no CSRF tokens are implemented.

# Preventing graphQL attacks

- Disable `introspection` if it is not required.
- If you must have `introspection` enabled, make sure no sensitive `field` data is exposed.
- Make sure `suggestions` are disabled.

# References

- [https://portswigger.net/web-security/graphql](https://portswigger.net/web-security/graphql)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL Injection/README.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)